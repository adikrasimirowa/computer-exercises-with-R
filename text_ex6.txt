Упражнение 6
 
# Тестове, доверителни интервали

зад. 1
При проверка на анкета 87 от 150 анкетирани са отговорили, че са използвали даден  продукт.
Постройте 95% доверителен интервал за броя на хората изпозлвали продукта.

# Xi in Bi(1,p)
# p~ = xn_=sum xi/n
#t=(xn_ -p)/(sqrt(p~(1-p~))/n)
#q1<t<q2 // q1+t+q2 =1
#p(xn_ - q*sqrt(xn_(1-xn_)/n))<p<xn_+q*sqrt(xn_(1-xn_)/n)

#xn=87/150
#t=0.95

# prop.test (x, n, p = NULL,
#alternative = c ("двустранно", "по-малко", "по-голямо"),
# conf.level = 0,95, правилно = ИСТИНСКО)

# prop.test може да се използва за тестване на нула, че пропорциите (вероятностите за успех) в няколко
# групите са еднакви или че са равни на определени дадени стойности.
#Arguments

#x - вектор на броя на успехите, едномерна таблица с два записа или двумерна таблица (или матрица) с 2 колони, като съответно се отчитат успехите и провалите.
# n - вектор от броя на изпитванията; игнорира се, ако x е матрица или таблица.
#p - вектор на вероятностите за успех. Дължината на p трябва да бъде същата като броя на групите, посочени с x, а елементите му трябва да са по-големи от 0 и по-малки от 1.
#alternative - символен низ, посочващ алтернативната хипотеза, трябва да бъде един от "two.sided" (по подразбиране), "по-голям" или "по-малък". Можете да посочите само първоначалната буква. Използва се само за тестване на нула, че една пропорция е равна на дадена стойност или две пропорции са равни; игнорирано по друг начин.
# conf.level - ниво на доверие на върнатия доверителен интервал. Трябва да е единично число между 0 и 1. Използва се само при тестване на нула, че една пропорция е равна на дадена стойност или две пропорции са равни; игнорирано по друг начин.
#correct - логично указване дали корекцията на Yates трябва да се прилага, когато е възможно.

#prop. test(87,150,conf.level=0.95)
#t=prop. test(87,150,conf.level=0.95) # в t има променливи


#conf.int(level = 0.95, size = 50, cl = c("red", "gray"), ...)
#Аргументи:

#level - нивото на доверие (1 ? ?), напр. 0.95
#size - размер на пробата за изтегляне на проби от N (0, 1)
#cl - два различни цвята за пояснение дали интервалите на доверие покриват истинската средна стойност (cl [1]: не; cl [2]: да)

# t $ conf.int [1] / [2] граници


conf.intervals=function()
{
  xn=87/150
  q1=qnorm(0.025)
  q2=qnorm(0.975)
  c=sqrt(xn*(1-xn)/150)
  d1=xn+q1*c
  d2=xn+q2*c
  return(c(d1,d2))
}
conf.intervals() # [1] 0.5010156 0.6589844
zad1.prop=function()
{
  t=prop.test(87,150,conf.level = 0.95)
  return(c(t$conf.int[1],t$conf.int[2]))
}
zad1.prop() #[1] 0.4966533 0.6591851

зад. 2
Острата левкимия е една от най-смъртоностните форми на рак. Предишни изследвания показват, че времето на 
преживяване след първоначалното откриване на левкемия е нормално разпределена случайна величина с математическо
очакване 13 месеца и стандартно отклонение 3 месеца. въвежда се ново лечение като се очаква то да удължи средното 
време на живто без да повлияе на дисперсията. Наблюдават се 16 пациента:
10, 13.6, 13.2, 11.6, 12.5, 14.2, 14.9, 14.5, 13.4, 8.6, 11.5, 16,14.2, 16.8, 17.9, 17
Постройте 95% доверителен интервал за средното време на живот на болните. Постройте същия интервал,
в случай на неизвестна дисперсия.

#доверителен интервал, когато знаем дисперсията
#X in N(13,3^3) # EX=13, VarX =3^2 , stand.def=3
#t=(Xn_-EX)/sqrt((VarX)^2/4)
#p(Xn_ - q*sqrt((VArX)^2/n))< EX< Xn_ + q*sqrt((Varx)^2/n)
#x=scan() въвеждане

zad2.dopINt=function()
{
  #n=16
  arr=c(10, 13.6, 13.2, 11.6, 12.5, 14.2, 14.9, 14.5, 13.4, 8.6, 11.5, 16, 14.2, 16.8, 17.9, 17)
  xn=sum(arr)/length(arr)
  q1=qnorm(0.02)
  q2=qnorm(0.98)
  c=3/4
  d1=xn+q1*c
  d2=xn+q2*c
  return(c(d1,d2))
}
zad2.dopINt()  #[1] 12.20344 15.28406

#доверителен интервал, когато не знаем мат. очакване и дисперсията
#S^2=sum(xi-x_n)^2/n-1
#S^2=vor(xi)
#t=(xn_ -EX)/sqrt(S^2/4)
#t.test() # използваме този тест, когато е нормално разпределение
#wilcox.test()   #  използваме този тест, когато не е нормално разпределени

zad2.novar=function()
{
  arr=c(10, 13.6, 13.2, 11.6, 12.5, 14.2, 14.9, 14.5, 13.4, 8.6, 11.5, 16, 14.2, 16.8, 17.9, 17)
  res=t.test(arr,conf.level=0.95)
  return(c(res$conf.int[1],res$conf.int[2]))
}
zad2.novar() #[1] 12.39066 15.09684

Зад. 3
Разгледайте данните от пакета "malpract", съдържащ размера на злоупотребите при обществени поръчки от пакета 'UsingR'.
Намерете 95% доверителен интервал за средната стойност на злоупотребите.

#conf.int=T   изчислява се интервала
library(UsingR)
data(malpract)
malpract
#[1]  760  380  125  250 2800  450  100  150 2000  180  650  275  850 1700 1500 3000  390


zad3.confInt=function(x)
{
  res=wilcox.test(x,conf.int=T,conf.level=0.95)
  return(c(res$conf.int[1],res$conf.int[2]))
}
zad3.confInt(malpract) #[1]  320 1500

зад. 4
Разгледайте данните 'rat'  от пакета 'UsingR'. Намерете 90% доверителен интервал за средното време
на преживяване на плъховете.

library(UsingR)
data (rat)
rat #[1] 152 152 115 109 137  88  94  77 160 165 125  40 128 123 136 101  62 153  83  69
matr=matrix(rat, nrow=5,ncol-4) #turns vector into matrix
zad.4.dovInt=function(x)
{
  res=t.test(x,conf.level=0.95)
  return(c(res$conf.int[1],res$conf.int[2]))
}
zad.4.dovInt(rat) #[1]  96.69997 130.20003

зад.5 
Генерирайте 30 наблюдения над случайна величина, която е нормално разпределена с очакване 5 и дисперси1 4. 
Постройте 92% доверителен интервал за математическото очакване. Повторете опита 100 пъти. Проверете в колко от случаите
математическото очакване принадлежи на доверителния интервал.

#matplot(x,y,type=l) Чертае колоните на една матрица срещу колоните на друга.
# matlines (x, y, type = "l", lty = 1:5, lwd = 1, pch = NULL, col = 1:6, …)
#  x,y - вектори или матрици от данни за начертаване. Броят на редовете трябва да съвпада.
# Ако една от тях липсва, другата се приема като y и се използва x вектор от 1: n. Липсващи стойности (NA) са позволени.
# type -    символен низ (вектор с дължина 1) или вектор от 1-знакови низове, указващи типа на графиката за всяка 
#колона на y, вижте графиката за всички възможни типове. Първият символ от типа определя първия сюжет, вторият символ вторият и т.н. например, "pl" последователно изчертава точки и линии.
# lty, lwd - вектор от типове линии, ширини и крайни стилове. Първият елемент е за първата колона, вторият за втората колона и т.н., дори ако линиите не са очертани за всички колони. Типовете линии ще се използват циклично, докато не бъдат изчертани всички участъци.
#PCH - символен низ или вектор от 1 символа или цели числа за нанасяне на символи, вижте точки. Първият символ е графичният символ за първия сюжет, вторият за втория и т.н. По подразбиране са цифрите (1 до 9, 0), след това малките и главни букви.
#col- vector of colors. Colors are used cyclically.

zad5.dovInt=function()
{
  matrix=matrix(c(0,0),2,1);
  cnt=0;
  for(i in 1:100)
  {x=rnorm(30,mean=5,sd=4)
  t=t.test(x,conf.level=92/100)
  matrix=cbind(matrix,c(t$conf.int[1],t$conf.int[2]))
               if(5>t$conf.int[1] &&5<t$conf.int[2])
               {cnt=cnt+1
               }
  }
matrix=matrix[,2:ncol(matrix)]
y=rbind(c(1:100),c(1:100))
matplot(matrix,y,type='l')
print(cnt)
return(matrix)
}
