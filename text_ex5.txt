Упражнение 5
 
# Непр. сл. вел

зад. 1

Генерирайте наблюдения над нормално разпределена сл. вел. X. Постройте хитограма. 
Добавете емпиричната и теоретичната плътност. Проследете как се променя емпиричната плътност 
при нарастване на броя на наблюденията. 

exp.razpredelenie=function()
{
  x=rnorm(1000)
  hist(x,probability=T)
  curve(dnorm(x),add=T)
  lines(density(y), col('red'))
  curve(dnorm(x),add=T)
  
}
mf=function(n=100)
{
  y=rnorm(100) 
  hist(y,Probability=T)
  for(i in 1:100){
    y=c(y,rnorm(10*i))
    hist(y,probability = T,
         breaks=c(seq(-5,5,0.25)),
         ylim=c(0.0,0.6))  #c(0.0,0.2,0.4,0.6)
  #empirical
    lines(density(y),col='red')
    #theoretical
    curve(dnorm(x),add=T)
    text(-4,0.6,i)
    Sys.sleep(0.1)
    }
}
exp.razpredelenie()

зад. 2
Нека сл. вел. X  е стандартно нормално разпределена,т.е. X in N(0,1). Генерирайте 100 наблюдения.
Каква част от тях са в интервалите А=(-1,1), B=(-2,2), C=(-3,3). Пресметнете теоретичните
вероятности X  да принадлежи на тези интервали. Обобщете за  произволна нормална разпределена случайна величина.
fun=function()
{
  y=rnorm(100)
  inA=sum(y>-1 & y<1)
  print(inA)
  #theretical probability to be in the interval
  print(pnorm(1)-pnorm(-1)) # end - begin
  inB=sum(y>-2 & y<2)
  print(inB)
  print(pnorm(2)-pnorm(-2)) # end - begin
  inC=sum(y>-3 & y<3)
  print(inC)
  print(pnorm(3)-pnorm(-3))
}
fun()
#[1] 72
#[1] 0.6826895
#[1] 97
#[1] 0.9544997
#[1] 100
#[1] 0.9973002

зад. 3
Нормално разпределена случайна величина X in N(25,36).  Пъпешите са разпределни в 3 групи, по-малките от 20 см 
се смятат за 3-то качество, а останлите се разделят на две равни части. Каква част са трето качество?
Колко голям трябва да е пъпеша, за да е първо качество?

pipesh=function()
{
#quantile - откъде наляво, математическо очакване, стандартно отклонение
p=pnorm(20,25,6)
#вероятността до quantil-a, който търсим, математическо очакване, стандартно отклонение
qnorm((1-p)/2+p,25,6)
}
  pipesh() #[1] 25.85636

зад. 4
Напишете функция, която по зададен параметър n. Генерирайте по 100 наблюдения за всяка една от 
случайните величини X1,X2,...,Xn и връща вектор Y=X1+X2+...+Xn. В случая, когато:
а) Xi  са равномерно разпределение [1,5];
б) Xi са експоненциално разпределени с параметър lambda=4;
в) Xi са биномно разпределени Bi(3,0.2);
какво можете да кажете за разпределението на Y. Разгледайте случайните n=1,2,10,100,1000.
За кое n разпределение започва да прилича на нормално?

#симетрично разпредление
# къси, нормални, дълги опашки -показва разпръстването
# qqnorm(x) - създава картинка, която показва до колко е нормално разпределение 
# qqine(x) - чертае линията
# x са данните 
# сумата на редица случайни величини е нормално разпределени | Централна гранична теорема

zad4a=function(n)
{
i=0
Y=runif(100,1,5)
while(i<n-1)
{Y=Y+runif(100,1,5)
i=i+1}
return(Y)}

zad4b=function(n)
{
i=0
Y=rexp(100,5)
while(i<n-1)
{
Y=Y+rexp(100,4)
i=i+1}
return(Y)
}
zad4c=function(n,second=3)
{
i=0
Y=rbinom(100,second,0.2)
while(i<n-1)
{
Y=Y+rbinom(100,second,0.2)
i=i+1}
return(Y)
}

зад.5
Разгледайте данните 'anscombe'. За всяка двойка променливи Xi,Yi  определете:
математическите очаквания, дисперсията, коефициента на корелацията. Представете данните графично.

# точкови оценки
# EX -mean(x) математическо очакване
# DX - var(x) дисперсия
# Standard deviation - (sqrt Dx) - sd(x) стандартно отклонение
# x - distribution  разпределение
# cov(X,Y) - covariance ковариация
# cor(X,Y) -  coрrelation  корелация

# dataframe: anscombe$x1; anscome[,x1]; attach(anscome)
#lm(formula =y~x)  връща коефициентите на правата (линейна регресия)
# abline(lm(formula= y~x)) чертае 
#plot(x,y)  показва данните разпръстнати , графично показване

zad5EX=function(x,y)
{
plot(mean(x),mean(y))
abline(lm(y~x))
}
zad5DX=function(x,y)
{
plot(var(x),var(y))
abline(lm(y~x))
}
zad5Cov=function(x,y)
{
plot(cov(x,y))
abline(lm(y~x))
}
zad5Cor=function(x,y)
{
plot(cor(x,y))
abline(lm(y~x))
}